# -*- coding: utf-8 -*-
"""
/***************************************************************************
 geemapDockWidget
                                 A QGIS plugin
 This plugin provides a GUI interface for Google Earth Engine and Python using the geemap module
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-07-21
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Brandon Crosbie
        email                : jamwamb7@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
import json
import requests
import time
import datetime


# For Map Interaction
from qgis.core import *


# For GUI/Widget Creation

from qgis.PyQt import QtGui, QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal

# For Datatypes
from PyQt5.QtGui import QStandardItemModel, QStandardItem,  QDoubleValidator, QIntValidator

# For Pop Up StatusBar Messages/Warnings/file handling 
from PyQt5.QtWidgets import QFileDialog, QDialog, QMessageBox, QWidget, QGridLayout, QLabel, QMenu, QStatusBar

# For auto Completer
from PyQt5.QtWidgets import QCompleter

# For Results List Buttons
from PyQt5.Qt import Qt

# For Results List
from PyQt5.QtCore import QVariant

# For Time Filter
from PyQt5.QtCore import QDate


# EXTRA REQUIREMENTS
# Requires Pip/Conda Installation for QGIS
from bs4 import BeautifulSoup


# # Declare save form class briefly
# SAVE_FORM_CLASS, _ = uic.loadUiType(os.path.join(
#     os.path.dirname(__file__), 'geemap_dockwidget_save_results.ui'))
# class geemapDockWidgetSaveResults(QDialog, SAVE_FORM_CLASS):
    
#     closingPlugin = pyqtSignal()

#     def __init__(self, parent=None):
#         """Constructor,"""
#         super(geemapDockWidgetSaveResults, self).__init__(parent)
#         self.setupUi(self)

#     def closeEvent(self, event):
#         self.closingPlugin.emit()
#         event.accept()



FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'geemap_dockwidget_base.ui'))


class geemapDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(geemapDockWidget, self).__init__(parent)
        # Set up the user interface from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://doc.qt.io/qt-5/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        #=====================================
        # User added init methods Google Earth Engine Plugin
        #=====================================

        # The Catalog is the total options list for Result Attribute, Save to files later
        self.catalog = []
        self.results = None

        # User defined Form Start Button Method
        self.formBeginStartBTN.clicked.connect(self.Start)

        # User defined Form Reset Button Method
        self.formBeginResetBTN.clicked.connect(self.Reset)
        

        # ===== Attributes Group =====
        # Drop Down: Dataset Type
        self.dataset_types = []
        # Allows reverse lookup on Dataset Type
        self.type_id_lookup = {}

        # Drop Down: Dataset Publisher:
        self.dataset_publishers = []
        # Allows reverse lookup on Publisher
        self.publisher_id_lookup = {}

        # Initialize Combo Box Features: Dataset Type
        self.filterDatasetTypeCB.setDuplicatesEnabled(False)
        self.filterDatasetTypeCB.currentTextChanged.connect(self.change_on_dataset_type)

        # Initialize Combo Box Features: Dataset Publisher
        self.filterDatasetPublisherCB.setDuplicatesEnabled(False)
        self.filterDatasetPublisherCB.currentTextChanged.connect(self.change_on_publisher)

        # Line Entry: Tags
        # Running list of tags in filter
        self.tag_list = []
        # Total tag list in all results
        self.all_tags = []
        # Allows reverse lookup on tag
        self.tag_id_lookup = {}

        # Initialize Clear Tag Button
        self.filterTagClearBTN.clicked.connect(self.clearFilterOptions)

        # Initialize Tag AND|OR radio buttons
        self.filterTagOrRB.setChecked(True)
        self.filterTagAndRB.setChecked(False)
        self.filterTagOrRB.toggled.connect(self.tagLogicSwitch)
        self.filterTagAndRB.toggled.connect(self.tagLogicSwitch)

        # Enable press Return for LE to enter Tags
        self.filterTagSelectLE.returnPressed.connect(self.updateTagList)

        # ===== Time Group =====
        # Start
        self.filterTimeStartDE.setDisplayFormat("yyyy-MM-dd")
        self.filterTimeStartDE.setMaximumDate(QDate.currentDate().addDays(-1))
        self.filterTimeStartDE.dateChanged.connect(self.change_start_date)
        # End
        self.filterTimeEndDE.setDisplayFormat("yyyy-MM-dd")
        self.filterTimeEndDE.setMaximumDate(QDate.currentDate())
        self.filterTimeEndDE.setDate(QDate.currentDate())
        self.filterTimeEndDE.dateChanged.connect(self.change_end_date)
        # self.filterTimeEndDE.setMinimumDate(self.filterTimeStartDE.date().addDays(1))

        # Initialize First/Last buttons
        self.filterTimeMinBTN.clicked.connect(self.beginningOfTime)
        self.filterTimeMaxBTN.clicked.connect(self.endOfTime)

        # Time Radio Buttons
        self.filterTimeCustomRB.setChecked(True)
        self.filterTimeCustomRB.toggled.connect(self.timeLogicSwitch)
        self.filterTimeYtdRB.toggled.connect(self.yearToDate)
        self.filterTimeYr1RB.toggled.connect(self.yearOne)
        self.filterTimeMn6RB.toggled.connect(self.monthSix)
        self.filterTimeMn3RB.toggled.connect(self.monthThree)
        self.filterTimeMn1RB.toggled.connect(self.monthOne)


        # ===== SEARCH ===== 
        # Connect Search Button to update List View of Results
        self.searchAllBTN.clicked.connect(self.Search)

        # ===== Results Group =====
        self.resultsSelectClearAllBTN.clicked.connect(self.clearAll)
        self.resultsSelectSelectAllBTN.clicked.connect(self.selectAll)
        self.resultsSelectInvertBTN.clicked.connect(self.invertAll)
        self.resultsSelectCalculateRequestsBTN.clicked.connect(self.GetMoreInfo)

        # ===== Location Group =====
        # Initialize the Lat/Lon format Line Edit
        self.locationSearchLatitudeLE.setValidator(QDoubleValidator(-90, -90, 9))
        self.locationSearchLongitudeLE.setValidator(QDoubleValidator(-180, 180, 9))
        self.locationSearchBTN.clicked.connect(self.find_me)

        # ===== GeoFilter Group =====
        self.locationFilterRadiusLE.setValidator(QDoubleValidator(0, 10000000, 9))
        self.locationFilterUnitKmRB.setChecked(True)
        self.locationFilterUnitMiRB.setChecked(False)
        self.locationFilterUnitKmRB.toggled.connect(self.unitLogicSwitch)
        self.locationFilterUnitMiRB.toggled.connect(self.unitLogicSwitch)

        self.locationFilterGeometryCB.setDuplicatesEnabled(False)
        self.locationFilterGeometryCB.addItem('Hexagon')
        self.locationFilterGeometryCB.addItem('Rectangle')

        self.locationFilterApplyBTN.clicked.connect(self.generate_polygon_poi)
        self.locationFilterImportTB.clicked.connect(self.select_import_shape)
        self.locationFilterImportBTN.clicked.connect(self.importShapefile)

        # For Interactive Drawing:
        self.locationFilterDrawLastBTN.clicked.connect(self.getLastGeometry)
        self.locationFilterDrawAllBTN.clicked.connect(self.getAllGeometry)

        # ===== Automation Group =====
        # estimate number of requests from query filter results
        self.automationSubmitRequestBTN.clicked.connect(self.submitRequest)
        self.automationCreateScriptBTN.clicked.connect(self.createScript)

        # ===== Save Group =====
        #self.resultsSelectSaveResultsBTN.clicked.connect(self.saveResults)

        #=====================================
        # End of User added init methods
        #=====================================
   

    #==============================================================
    # Default class method "closeEvent" from QGIS Plugin Builder
    #==============================================================
    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    #==============================================================
    










    #==============================================================
    # User Custom class methods: required CRUD across multiple Groups
    #==============================================================
    

    
    #=====================================
    # (script: ee_catalog.py) webscrape using bs4 
    #=====================================
    def init_ee_catalog(self):
        """ Script will automatically import the catalog JSON
            OR if no file exists, run the webscraper to extract metadata"""
        from .scripts import ee_catalog
        catalog = ee_catalog.read_catalog()
        self.catalog = catalog

    
    #=====================================
    # First Check EE Plugin Installed (Already Native to QGIS) 
    #=====================================
    def init_ee_plugin(self):
        """Run this with Start"""
        try:
            import ee
            # from ee_plugin import Map
        except Exception as e:
            QMessageBox.information(self, 'EE PLUGIN MISSING', str(e), QMessageBox.Ok)

        return


    #=====================================
    # Check used for selection iteration for current results
    #=====================================

    def check_results(self):
        """ Results initialized as None
            some functions will need to check catalog 
            i.e. for drop down/list options """

        if self.results is None:
            return self.catalog

        else:
            return self.results


    


    #=====================================
    # the findAll Series produces reverse lookup dictionaries
    #=====================================
    
    def findAll_DatasetTypes(self):
        """ For all Dataset Types: Image/ImageCollection/FeatureCollection """
        # When changing Dataset Type, we need to refresh from entire catalog
        selection = self.catalog
        
        dataset_types = []
        type_id_lookup = {}
        for dataset in selection:
            d_type = dataset['dataset_type']

            # REORG: Datatype-> datasets
            # This will reorg the dataset types to lookup easily
            if d_type not in dataset_types:
                dataset_types.append(d_type)
                type_id_lookup.update({d_type: [dataset]})

            else:
                type_id_lookup[d_type].append(dataset)

        self.dataset_types = dataset_types
        self.type_id_lookup = type_id_lookup
        return

    
    def findAll_DatasetPublishers(self):
        """ Publisher not exact, uses first element of str.split in URL"""
        selection = self.check_results()
        dataset_publishers = []
        publisher_id_lookup = {}

        for dataset in selection:
            d_id = dataset['dataset_id']
            
            # now use first ID , later integrate actual publisher tags,
            d_publisher = get_publisher(dataset)
            
            if d_publisher not in dataset_publishers:
                dataset_publishers.append(d_publisher)
                publisher_id_lookup.update({d_publisher: [dataset]})
            else:
                publisher_id_lookup[d_publisher].append(dataset)

        self.dataset_publishers = dataset_publishers
        self.publisher_id_lookup = publisher_id_lookup
        return


    def findAll_Tags(self):
        """ Tags are provided in their own list format"""
        selection = self.check_results()

        # For all Tags, reverse lookup ability
        all_tags = []
        tag_id_lookup = {}
        
        for dataset in selection:
            d_tags = dataset['tags']
            # This will reorg the tags to look up all dataset id's 
            for tag in d_tags:
                if tag not in all_tags:
                    all_tags.append(tag)
                    tag_id_lookup.update({tag: [dataset]})
                else:
                    tag_id_lookup[tag].append(dataset)

        self.all_tags = all_tags
        self.tag_id_lookup = tag_id_lookup
        return


    def reorganize_catalog(self):
        """ Reorganize Catalog for avaliable dataset types/id's/tags """ 
        self.findAll_DatasetTypes()
        self.findAll_DatasetPublishers()
        self.findAll_Tags()
        return



    #=====================================
    # Create Drop Down Menu for dataset types
    #=====================================

    def setDropDown_DatasetType(self):
        """ Top Level Filter: 
        need to reset all other drop downs when this is changed"""
        self.filterDatasetTypeCB.clear()
        # First list item should be <blank> or '' for 'All' 
        self.filterDatasetTypeCB.addItem('')

        # run a quick update on the dataset types based on selection
        self.findAll_DatasetTypes()
        for dtype in self.dataset_types:
            self.filterDatasetTypeCB.addItem(str(dtype))

        # Somehow it needs to update filter options every time
        self.updateFilterOptions()

        return

    #=====================================
    # Create Drop Down Menu for Publisher:
    #=====================================

    def setDropDown_Publisher(self):
        self.filterDatasetPublisherCB.clear()
        # Default first option blank ('')
        self.filterDatasetPublisherCB.addItem('')

        # Run Update on all dataset publishers based on selection
        self.findAll_DatasetPublishers()
        for dpub in self.dataset_publishers:
            self.filterDatasetPublisherCB.addItem(str(dpub))

        return

    #=====================================
    # Create Tag list method
    #=====================================

    def setOptions_Tags(self):
        # tag search needs to be based off of 
        self.findAll_Tags()
        # completer = QCompleter(self.all_tags, self.filterTagSelectLE)
        completer = QCompleter(self.all_tags, self)
        self.filterTagSelectLE.setCompleter(completer)
        return
    





    #=====================================
    # UPDATES: Filtering in Real Time
    #=====================================

    def filterDatasetType(self):
        """ filter on dataset Type, skip if blank"""
        dd_type = self.filterDatasetTypeCB.currentText()
        if dd_type != '':
            selection = self.catalog
            filtered = []

            for dataset in selection:
                if dataset['dataset_type'] == dd_type:
                    filtered.append(dataset)

            self.results = filtered

        else:
            self.results = self.catalog

        return



    def filterPublisher(self):
        """ filter on Publisher drop down if blank skip"""

        dd_pub = self.filterDatasetPublisherCB.currentText()

        if dd_pub != '':
            selection = self.check_results()
            filtered = []

            for dataset in selection:
                dataset_pub = get_publisher(dataset)
                if dataset_pub == dd_pub:
                    filtered.append(dataset)

            self.results = filtered

        return



    def filterTags(self):
        """ filter on Tags in user's list, if blank skip """
        self.read_tags()

        if self.tag_list:
            selection = self.check_results()
            filtered = []

            # satisfied all, if just False once, ruins the AND case
            satisfied_all = True

            # satisfied one, just needs to succeed once, for OR case
            satisfied_one = False

            for dataset in selection:
                for tag in self.tag_list:
                    if tag not in dataset['tags'] and self.filterTagAndRB.isChecked():
                        satisfied_all = False
                    elif tag in dataset['tags']:
                        satisfied_one = True
                    else:
                        pass

                if satisfied_one:
                    if self.filterTagAndRB.isChecked() and satisfied_all:
                        filtered.append(dataset)
                    else:
                        filtered.append(dataset)

            # Update the results, only if there was a tag list 
            self.results = filtered

        return



    def filterTime(self):
        """ Should Break each filter into own function... 
        Filter On Time"""

        selection = self.check_results()
        filtered = []

        filter_start = self.filterTimeStartDE.date()
        filter_end = self.filterTimeEndDE.date()

        for dataset in selection:
            start = convert_date(dataset['dataset_start'])
            end = convert_date(dataset['dataset_end'])

            if start is None or end is None:
                filtered.append(dataset)

            else:
                # QDate(year, month, day)
                start = QDate(start.year, start.month, start.day)

                # Now Get End Date
                if end == 'Present':
                    end = QDate.currentDate()
                    end = QDate(end.year(), end.month(), end.day())
                
                else:
                    end = QDate(end.year, end.month, end.day)


                # Last Check!

                if start <= filter_end and filter_start <= end:
                    filtered.append(dataset)


        # Update the attribute Results
        self.results = filtered

        return




    def filter_results(self):
        """ Order of Filter Operations: 
        1. Dataset Type (Image/ImageCollection/FeatureCollection)
        2. Publisher 
        3. Tags
        4. Time

        *NOTE: Location NEEDS MORE INFO from metadata"""

        # Flter 1: Dataset Type Drop Down Menu
        self.filterDatasetType()

        # Filter 2: Publisher Drop Down Menu
        self.filterPublisher()

        # Filter 3: Tags
        self.filterTags()

        # Filter 4: Time
        self.filterTime()

        # Now call those reorg functions
        self.reorganize_catalog()
        # self.beginningOfTime()
        # self.endOfTime()


        return
    

    #==============================================================

    def updateFilterOptions(self):
        """ Trigger When New Attribute Added to Filter to make Subset """
        self.filter_results()
        self.updateResultsList()
        self.setOptions_Tags()
        return

    def clearFilterOptions(self):
        """ Trigger When New Attribute Does not fit in Primary Dataset Type"""
        self.clearTagOptions()
        self.filter_results()
        self.updateResultsList()
        return

    def resetFilterOptions(self):
        """ Trigger When Primary Dataset Type Filter Altered"""
        self.filter_results()
        self.setDropDown_Publisher()
        self.updateResultsList()
        self.reorganize_catalog()
        return


    #==============================================================










    #==============================================================
    # Form Begin: Start/Reset 
    #============================================================== 
    
    #=====================================
    # 0. Start Button
    #=====================================

    def Start(self):
        """ Run webscrape/file import to load GEE Catalog (metadata)"""
        
        # Initialize the catalog
        self.init_ee_catalog()

        # Initialize EE plugin
        self.init_ee_plugin()

        # Set Earliest Time
        self.beginningOfTime()
        # Now set the minimumDate for start from the total dataset
        self.filterTimeStartDE.setMinimumDate(self.filterTimeStartDE.date())

        # AutoFill the Drop Down if empty
        if self.filterDatasetTypeCB.count() == 0:
            self.setDropDown_DatasetType()

        if self.filterDatasetPublisherCB.count() == 0:
            self.setDropDown_Publisher()

        self.setOptions_Tags()

         # initialize the map
        base_layer = init_map()
        # Start the QgsProject
        QgsProject.instance().addMapLayer(base_layer)
        QgsProject.instance().setCrs(base_layer.crs())


        return

    #=====================================
    # 1. Reset Button
    #=====================================

    def Reset(self):
        reset_msg = QMessageBox()
        reset_msg.setIcon(QMessageBox.Information)

        reset_msg.setText("Reseting Form")
        reset_msg.setInformativeText("Are you sure?")
        reset_msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        response = reset_msg.exec()
        if response == QMessageBox.Ok:
            # Reset Procedure:
            # clear dataset type/publisher drop downs
            self.filterDatasetTypeCB.clear()
            self.filterDatasetPublisherCB.clear()

            # clear Tags (should already be a function)
            self.filterTagSelectLE.clear()

            # Time
            self.filterTimeCustomRB.setChecked(True)
            self.filterTimeEndDE.setMaximumDate(QDate.currentDate())
            self.filterTimeEndDE.setDate(QDate.currentDate())
            self.filterTimeStartDE.setMaximumDate(QDate.currentDate().addDays(-1))
            self.filterTimeStartDE.setDate(QDate(1980,1,1))

            # clear Lat/Lon
            self.locationSearchLatitudeLE.clear()
            self.locationSearchLongitudeLE.clear()

            # clear Radius and Import
            self.locationFilterRadiusLE.clear()
            self.locationFilterUnitKmRB.setChecked(True)
            self.locationFilterImportLE.clear()

            # clear Results List View, and Tag List View
            m = QStandardItemModel()
            self.resultsSelectLV.setModel(m)
            self.filterTagSelectLV.setModel(m)

            # Set results counter to 0
            self.lcdNumber.display(0)

            # Finally
            self.results = None
            self.Start()


        return


    #==============================================================
    # END OF Form Begin Group
    #==============================================================











    #==============================================================
    # Attributes Group
    #==============================================================
    

    def change_on_dataset_type(self):
        """ specific handler of DatasetType Drop Down"""
        self.resetFilterOptions()
        return

    def change_on_publisher(self):
        """NOTE*: use clearFilterOptions, not Reset, when changing Publisher, just clear """
        self.clearFilterOptions()
        return


    def tagLogicSwitch(self):
        """ automatically switch to other Radio Button Mode OR|AND"""
        if self.filterTagOrRB.isChecked():
            self.filterTagAndRB.setChecked(False)
        elif self.filterTagAndRB.isChecked():
            self.filterTagOrRB.setChecked(False)
        else:
            pass
        
        self.clearTagOptions()
        return

    
    def clearTagOptions(self):
        self.tag_list = []
        m = QStandardItemModel()
        self.filterTagSelectLV.setModel(m)
        self.filterTagSelectLE.clear()

        return

    #=====================================
    # Tag List View Model
    #===================================== 

    def read_tags(self):
        tag_list = []
        try:
            for i in range(self.filterTagSelectLV.model().rowCount()):
                if self.filterTagSelectLV.model().item(i).checkState() == Qt.Checked:
                    tag_list.append(self.filterTagSelectLV.model().item(i).text())

        except:
            pass

        self.tag_list = tag_list
        return




    def updateTagList(self):
        # Two cases for update: 
        # 1. (DEFAULT) OR: Add any tag and include all in search results
        # 2. (Need to check) AND: Live update Tag list, All tags must match in results

        tag_list = self.tag_list
        new_tag = self.filterTagSelectLE.text()
        AND_mode = self.filterTagAndRB.isChecked()
        try:
            # First, Assert this tag is in all tags ot begin with (OR + AND)
            assert new_tag in self.all_tags, "Tag Not in EE Catalog"

            if new_tag not in tag_list:
                tag_list.append(new_tag)
            # Now Display Tags in ListView 
            m_tags = QStandardItemModel()
            # Auto Clear each time:
            self.filterTagSelectLV.setModel(m_tags)
            
            # Repop List View
            for tag in tag_list:
                item = QStandardItem(tag)
                item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
                item.setData(QVariant(Qt.Checked), Qt.CheckStateRole)
                m_tags.appendRow(item)

            self.tag_list = tag_list
            self.filterTagSelectLV.setModel(m_tags)
            self.filterTagSelectLE.clear()

            # when in AND mode, update the self.all_tags to only include tag overlap
            if AND_mode:
                # run update on results, find datasets with this tag
                selection = self.tag_id_lookup[new_tag]
                self.results = selection
                # Re-run the find_all functions, after filtering down results
                self.reorganize_catalog()
                # finally re-run set Options for autofilling
                self.setOptions_Tags()

            # Run the update
            self.updateFilterOptions()



        except Exception as e:
            # not really that important, but in case we need QMessage Info/Warning
            # THis Exception just prevents entering Tag before finished typing
            #QMessageBox.information(self, 'Unable to Add Tag', str(e.__class__) + ': ' + str(e), QMessageBox.Ok )
            pass



        return




    #==============================================================
    # END OF Attributes Group
    #==============================================================







    #==============================================================
    # Time Group
    #==============================================================

    def beginningOfTime(self, set_date=True):
        """ Find the First date in the current selection of results/catalog"""

        selection = self.check_results()


        if selection:
            min_date = QDate.currentDate().addDays(1)
        
            for dataset in selection:
                date = convert_date(dataset['dataset_start'])

                if date is not None:
                    dataset_date = QDate(date.year, date.month, date.day)
                    if dataset_date < min_date:
                        min_date = dataset_date


            # IF min date remains the same, warning, no dates found
            if min_date == QDate.currentDate().addDays(1):
                self.no_dates_found()

            # if new min was set, and we want to set the form, check flag
            elif set_date:
                self.filterTimeStartDE.setDate(min_date)
                self.filterTimeCustomRB.setChecked(True)

            # if we don't want to set the form, just return the min date
            else:
                return min_date

        # if there was no selection, just return value of the set start
        else:
            return self.filterTimeStartDE.date()






    def endOfTime(self, set_date=True):
        """ Find the Last date in the current selection of results/catalog"""
        selection = self.check_results()

        if selection:
            max_date = self.filterTimeStartDE.date().addDays(-1)

        
            for dataset in selection:
                date = convert_date(dataset['dataset_end'])


                if date == 'Present':
                    max_date = QDate.currentDate()
                    break

                elif date is None:
                    max_date = QDate.currentDate()
                    break

                else:
                    # QDate(year, month, day)
                    dataset_date = QDate(date.year, date.month, date.day)
                    if dataset_date > max_date:
                        max_date = dataset_date


            # Last Validation, if the max_date is same as the initial max, don't change
            if max_date == self.filterTimeStartDE.date().addDays(-1):
                max_date = self.filterTimeEndDE.date()



            elif set_date:
                self.filterTimeEndDE.setDate(max_date)
                self.filterTimeCustomRB.setChecked(True)


            else:
                return max_date

        else:
            max_date = self.filterTimeEndDE.date()
            return max_date



    def date_validation(self, auto_fix=True):
        """ Run this every time Search is clicked, to throw warning if dates
        Are not valid for dataset list, and automatically snap to boundary"""
        
        selection = self.catalog

        filter_start = self.filterTimeStartDE.date()
        valid_start = self.beginningOfTime(set_date=False)


        if filter_start < valid_start and auto_fix:
            # print("Filter Start Out of Range: ", filter_start)
            self.filterTimeStartDE.setDate(valid_start)

        filter_end = self.filterTimeEndDE.date()
        valid_end = self.endOfTime(set_date=False)

        try:
            if filter_end > valid_end and auto_fix:
                # print("Filter End Out of Range: ", filter_end)
                self.filterTimeEndDE.setDate(valid_end)
        except TypeError as e:
            # print(e)
            self.date_out_of_range()

        return



    def change_start_date(self):
        """ dynamically set new Minimum for end based on changed start"""
        old_end = self.filterTimeEndDE.date()
        new_start = self.filterTimeStartDE.date()
        if old_end < new_start:
            self.filterTimeEndDE.setDate(new_start.addDays(1))
        return

    def change_end_date(self):
        self.filterTimeCustomRB.setChecked(True)
        return


    def timeLogicSwitch(self):
        if self.filterTimeCustomRB.isChecked():
            self.filterTimeYtdRB.setChecked(False)
            self.filterTimeYr1RB.setChecked(False)
            self.filterTimeMn6RB.setChecked(False)
            self.filterTimeMn3RB.setChecked(False)
            self.filterTimeMn1RB.setChecked(False)

        elif self.filterTimeMn1RB.isChecked():
            self.filterTimeCustomRB.setChecked(False)
            self.filterTimeYtdRB.setChecked(False)
            self.filterTimeYr1RB.setChecked(False)
            self.filterTimeMn6RB.setChecked(False)
            self.filterTimeMn3RB.setChecked(False)

        elif self.filterTimeMn3RB.isChecked():
            self.filterTimeMn1RB.setChecked(False)
            self.filterTimeCustomRB.setChecked(False)
            self.filterTimeYtdRB.setChecked(False)
            self.filterTimeYr1RB.setChecked(False)
            self.filterTimeMn6RB.setChecked(False)

        elif self.filterTimeMn6RB.isChecked():
            self.filterTimeMn3RB.setChecked(False)
            self.filterTimeMn1RB.setChecked(False)
            self.filterTimeCustomRB.setChecked(False)
            self.filterTimeYtdRB.setChecked(False)
            self.filterTimeYr1RB.setChecked(False)

        elif self.filterTimeYr1RB.isChecked():
            self.filterTimeMn6RB.setChecked(False)
            self.filterTimeMn3RB.setChecked(False)
            self.filterTimeMn1RB.setChecked(False)
            self.filterTimeCustomRB.setChecked(False)
            self.filterTimeYtdRB.setChecked(False)

        elif self.filterTimeYtdRB.isChecked():
            self.filterTimeYr1RB.setChecked(False)
            self.filterTimeMn6RB.setChecked(False)
            self.filterTimeMn3RB.setChecked(False)
            self.filterTimeMn1RB.setChecked(False)
            self.filterTimeCustomRB.setChecked(False)

        else:
            pass


    def date_out_of_range(self):
        QMessageBox.information(self, 'Warning: Invalid Date', 'Date Out of Range: ' + str(self.filterTimeStartDE.date()), QMessageBox.Ok )

    def no_dates_found(self):
        QMessageBox.information(self, 'Warning: Missing Dates', 'No Dates Found in Results', QMessageBox.Ok)

    def yearToDate(self):
        """ This Button Will have the only override mechanism to set
        End Date to Current date automatically """
        self.timeLogicSwitch()
        self.filterTimeEndDE.setDate(QDate.currentDate())
        self.filterTimeStartDE.setDate(QDate(QDate.currentDate().year(), 1, 1))
        return



    def yearOne(self):
        new_start = self.filterTimeEndDE.date().addMonths(-12)
        if new_start >= self.filterTimeStartDE.minimumDate():
            self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            self.filterTimeCustomRB.setChecked(True)


    def monthSix(self):
        new_start = self.filterTimeEndDE.date().addMonths(-6)
        if new_start >= self.filterTimeStartDE.minimumDate():
            self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            self.filterTimeCustomRB.setChecked(True)
   

    def monthThree(self):
        new_start = self.filterTimeEndDE.date().addMonths(-3)
        if new_start >= self.filterTimeStartDE.minimumDate():
            self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            self.filterTimeCustomRB.setChecked(True)

    def monthOne(self):
        new_start = self.filterTimeEndDE.date().addMonths(-1)
        if new_start >= self.filterTimeStartDE.minimumDate():
            self.timeLogicSwitch()
            self.filterTimeStartDE.setDate(new_start)

        else:
            self.date_out_of_range()
            self.filterTimeCustomRB.setChecked(True)



    #==============================================================
    # END OF Time Group
    #==============================================================






    def Search(self):
        """ The Actual Search Button"""

        # Validate Parameters
        self.date_validation()
        
        # just start from the top each time
        self.results = self.catalog

        # reorg
        self.reorganize_catalog()

        # filter using all
        self.filter_results()

        # update List View of Results
        self.updateResultsList()








    #==============================================================
    # Results Group
    #==============================================================

    #=====================================
    # Results ListView
    #===================================== 

    def updateResultsList(self):
        """ Update List View for Current Results"""
        # Instantiate List View Model, from clear state each time
        m = QStandardItemModel()
        self.resultsSelectLV.setModel(m)
        
        selection = self.check_results()
        for dataset in selection:
            item = QStandardItem(dataset['dataset_id'] + '\t ('+str(dataset['dataset_type']) + ')' )
            item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
            item.setData(QVariant(Qt.Checked), Qt.CheckStateRole)
            m.appendRow(item)
        
        self.resultsSelectLV.setModel(m)

        # Display Results Count
        self.lcdNumber.display(len(self.results))
        return

    

    #=====================================
    # Results Button Selection
    #===================================== 

    def selectAll(self):
        """select all items of the list view widget"""
        for i in range(self.resultsSelectLV.model().rowCount()):
            self.resultsSelectLV.model().item(i).setCheckState(Qt.Checked)

        self.lcdNumber.display(self.resultsSelectLV.model().rowCount())

    def clearAll(self):
        """deselect all items of the list view widget"""
        for i in range(self.resultsSelectLV.model().rowCount()):
            self.resultsSelectLV.model().item(i).setCheckState(Qt.Unchecked) 
        
        self.lcdNumber.display(0)
            
    def invertAll(self):
        """invert current selection of the list view widget"""
        count = 0
        for i in range(self.resultsSelectLV.model().rowCount()):
            currentValue = self.resultsSelectLV.model().item(i).checkState()
            self.resultsSelectLV.model().item(i).setCheckState(Qt.Checked if currentValue == Qt.Unchecked else Qt.Unchecked)

            if currentValue == Qt.Unchecked:
                count += 1
        
        self.lcdNumber.display(count)


    def read_results(self):
        """ Read the list view and update the self.results"""
        results_list = []

        try:
            for i in range(self.resultsSelectLV.model().rowCount()):
                if self.resultsSelectLV.model().item(i).checkState() == Qt.Checked:
                    results_list.append(self.resultsSelectLV.model().item(i).text().split('\t')[0])
        except:
            self.results = results_list
            self.lcdNumber.display(len(results_list))

        else:
            real_data = []
            for dataset in self.catalog:
                if dataset['dataset_id'] in results_list:
                    real_data.append(dataset)
            self.results = real_data
            self.lcdNumber.display(len(real_data))

        return





    def GetMoreInfo(self):
        """ This will be used to query the getInfo() ee Method"""

        self.read_results()
        try:
            assert len(self.results) <= 1, "Please Limit Selection to 1"
            
            # Actual Earth Engine Python API
            import ee

            # 1. make a list of the ID's in the results
            # 2. Call the ee.ImageCollection("<dataset_id>").getInfo()
            dataset_id_list = []
            start = self.filterTimeStartDE.text()
            end = self.filterTimeEndDE.text()
            print(start)
            print(end)

            for dataset in self.results:

                dataset_id = dataset['dataset_id']
                dataset_type = dataset['dataset_type']

                if dataset_type == 'ImageCollection':
                    IC = ee.ImageCollection(dataset_id).filterDate(start, end)
                    info = IC.getInfo()
                    print(len(info))
                    for item in info:
                        print(item)


                elif dataset_type == 'Image':
                    print("COMING SOON!")
                    # image = ee.Image(dataset_id)
                    # info = image.getInfo()
                    # print(info)

                    # # Need to scan properties for vis parameters
                    # properties = info['properties']
                    # print(properties)

                    # # need to know bands in Image
                    # bands = info['bands']
                    # print(bands)

                    # # Check for CRS transform
    
 



                elif dataset_type == 'FeatureCollection':
                    print("COMING SOON!")



                else:
                    print("COMING SOON!")

        except Exception as e:
            print("DEVELOPING REQUEST CALCULATOR IN PROGRESS")
            QMessageBox.information(self, 'Too Much to Request', str(e), QMessageBox.Ok)




        
        return



    def saveResults(self):
        """open file dialog to select exising csv/text file and if accepted, update GUI accordingly"""
        # For now, only supporting .shp, next look at GeoPackage/GeoJson/CSV list of points
        supported_fileTypes = ['shp', 'csv', 'json']

        fileName, _ = QFileDialog.getSaveFileName(self, "Select Folder", "","(*.*)")
        
        try:
            fileType = fileName.split('.')[-1]
            filePath = os.path.dirname(fileName)
        except:
            fileType = ''
            filePath = ''
        else:
    
            if fileType not in supported_fileTypes:
                QMessageBox.information(self, 'Unsupported File Type', 'Cannot Import Type: {}\n'.format(fileType) + 'try: {}'.format(supported_fileTypes), QMessageBox.Ok)




    #==============================================================
    # END OF Results Group
    #==============================================================









    #==============================================================
    # Automation Group
    #==============================================================


    def submitRequest(self):
        print("COMING SOON!")

    def createScript(self):
        print("COMING SOON!")

    #==============================================================
    # END OF Automation Group
    #==============================================================
    










    #==============================================================
    # Location Group
    #==============================================================


    # Use Public IP info to get Approximate Lat/Long
    def find_me(self):
        """ Plot the Point specified in Locaiton 
        if blank, then use IP Lat/Lon Approximation lookup"""
        if self.locationSearchLatitudeLE.text() == '' or self.locationSearchLongitudeLE == '':
            from .scripts import common
            loc = common.find_me()
            lat = loc['lat']
            lon = loc['lon']

            # Display Lat/Lon in LE entry boxes
            self.locationSearchLatitudeLE.setText(str(lat))
            self.locationSearchLongitudeLE.setText(str(lon))

        else:
            lat = float(self.locationSearchLatitudeLE.text())
            lon = float(self.locationSearchLongitudeLE.text())


        plot_point(lon, lat)
        return



    #==============================================================
    # END OF Location Group
    #==============================================================
    







    #==============================================================
    # GeoFilter Group
    #==============================================================

    def unitLogicSwitch(self):
        if self.locationFilterUnitKmRB.isChecked():
            self.locationFilterUnitMiRB.setChecked(False)
        elif self.locationFilterUnitMiRB.isChecked():
            self.locationFilterUnitKmRB.setChecked(False)
        else:
            pass

        return


    def create_ee_geometry_from_poi(self, point_list):
        """ poi is a dictionary lookup, a list of lat/lon pairs"""
        for point in point_list:
            print("lat: ", point['latitude'])
            print("lon: ", point['longitude'], '\n')

        return

    def generate_polygon_poi(self):
        from .scripts import common 
        lat = self.locationSearchLatitudeLE.text()
        lon = self.locationSearchLongitudeLE.text()
        radius = self.locationFilterRadiusLE.text()

        try:
            assert isinstance(float(lat), float), "Latitude Error"
            assert isinstance(float(lon), float), "Longitude Error"
            assert isinstance(float(radius), float), "Radius Error"
        except:
            QMessageBox.information(self, 'Missing Inputs', 'Cannot Create GeoFilter', QMessageBox.Ok)
            return

        else:
            unit = 'km' if self.locationFilterUnitKmRB.isChecked() else 'mi'

            default_sides = 6 if self.locationFilterGeometryCB.currentText() == 'Hexagon' else 0
            sides = 4 if self.locationFilterGeometryCB.currentText() == 'Rectangle' else default_sides

            lat = float(lat)
            lon =float(lon)

            radius = float(radius)
            point_list = common.GeneratePolygon(lat, lon, radius, unit, sides)
            plot_polygon(point_list)
            # self.create_ee_geometry_from_poi(point_list)



    def select_import_shape(self):    
        """open file dialog to select exising csv/text file and if accepted, update GUI accordingly"""
        fileName, _ = QFileDialog.getOpenFileName(self, "Select .shp", "","(*.*)")
        fileType = fileName.split('.')[-1]
        
        # For now, only supporting .shp, next look at GeoPackage/GeoJson/CSV list of points
        supported_fileTypes = ['shp']

        if fileType in supported_fileTypes:
            self.locationFilterImportLE.setText(fileName)
            return fileName
        else:
            QMessageBox.information(self, 'Unsupported File Type', 'Cannot Import Type: ' + FileType, QMessageBox.Ok)
            return 


    def importShapefile(self):
        """ Connected to Import Button"""
        try:
            fileName = self.locationFilterImportLE.text()
            # assert fileName != '', "No File Selected"
            plot_shapefile(fileName)

        except Exception as e:
            print(e)
            QMessageBox.information(self, str(e), 'Please Choose a file to Import', QMessageBox.Ok)
            return



    def getLastGeometry(self):
        print("COMING SOON!")

    def getAllGeometry(self):
        import qgis.utils

        layer = qgis.utils.iface.activeLayer()
        print(layer.id())

        layer.selectAll()
        # for testing
        features = layer.getFeatures()
        for feature in features:
            print(feature.attributes())



    #==============================================================
    # END OF GeoFilter Group
    #==============================================================


#==============================================================
# FUNCTIONS not in class, handling the Datasets in Catalog List
#==============================================================

#=====================================
# Unified method of Extracting Dates from datasets in list
#=====================================

def convert_date(date):
    """ Extract the date with the known formats """
    try:
        # assert 'dataset_start' in dataset, "No dataset Key"
        # date = dataset['dataset_start']

        # Check 1: None
        if date is None:
            return None

        # Check 2: str(Present)
        elif date == 'Present':
            return date

        # Check 3: ISO
        else:
            # If this format fails, then Except below to different format
            date = datetime.datetime.fromisoformat(date)


    except KeyError as e:
        # QMessageBox.information(self, str(e), 'calling get date on wrong dataset or type', QMessageBox.Ok)
        print(e)
        print(dataset)
        date = None


    except TypeError as e:
        print(e)
        date = None


    # Check 4: Use custom strptime, non-ISO
    except Exception as e:
        date = datetime.datetime.strptime(date, "%Y-%m-%dT%H:%M:%S.%fZ")


    except:
        # new Date time format to check!
        # QMessageBox.information(self, "New DateTime Format", str(date), QMessageBox.Ok)
        print(date)
    
    finally:
        return date





#=====================================
# (Temp, but) Unified method of defining Publisher from Metadata
#=====================================

def get_publisher(dataset):
    
    try:
        assert 'dataset_id' in dataset
        publisher = dataset['dataset_id'].split('/')[0]
        return publisher
    except Exception as e:
        print(e)
        return None




#==============================================================
# FUNCTIONS to interact with QGIS Map
#==============================================================


#=====================================
# Init Map
#=====================================



def init_map(external_gui=False):
    # from PyQt5.QtWidgets import QApplication
    from qgis.core import QgsRasterLayer
    from qgis.core import QgsVectorLayer
    from qgis.core import QgsProject
    from qgis.core import QgsCoordinateReferenceSystem
    from qgis.utils import iface


    uri = r'crs=EPSG:3857&format&type=xyz&url=https://mt1.google.com/vt/lyrs%3Ds%26x%3D%7Bx%7D%26y%3D%7By%7D%26z%3D%7Bz%7D&zmax=19&zmin=0'
    layer = QgsRasterLayer(uri, 'google maps', 'wms')
    assert layer.isValid()

    # QgsProject.instance().addMapLayer(layer)

    # For External GUI

    from qgis.gui import QgsMapCanvas
    canvas = QgsMapCanvas()
    canvas.setWindowTitle('You Are Here')
    canvas.setLayers([layer])
    canvas.setExtent(layer.extent())
    canvas.setDestinationCrs(layer.crs())
    canvas.setDestinationCrs(QgsCoordinateReferenceSystem('EPSG:3857'))
    
    if external_gui:
        canvas.show()
        # app.exec_()

    else:
        return layer


#=====================================
# CRS Transformations
#=====================================

# def change_map_crs(self):
#     iface.newProject(False)
#     crs = QgsCoordinateReferenceSystem()


#=====================================
# Plot Point
#=====================================

def plot_point(longitude, latitude):
    poi = QgsPointXY(longitude, latitude)
    # poi = QgsGeometry.fromPointXY(QgsPointXY(lon, lat))
    v_layer = QgsVectorLayer("Point", "You Are Here", "memory")
    pr = v_layer.dataProvider()
    # create a new feature
    seg = QgsFeature()
    # add geometry to feature
    seg.setGeometry(QgsGeometry.fromPointXY(poi))

    # add attributes if necessary

    # update extent of layer
    pr.addFeatures( [ seg ] )
    v_layer.updateExtents()
    # show point
    QgsProject.instance().addMapLayer(v_layer)

#=====================================
# Draw Polygon
#=====================================

def plot_polygon(points):
    q_points = [QgsPointXY(p['longitude'], p['latitude']) for p in points]
    # close the loop
    q_points.append(q_points[0])

    # translate into QgsGeometry
    q_poly = QgsGeometry.fromPolylineXY(q_points)
    v_layer = QgsVectorLayer("LineString", "line", "memory")
    pr = v_layer.dataProvider()

    seg = QgsFeature()
    seg.setGeometry(q_poly)
    pr.addFeatures( [ seg ] )
    v_layer.updateExtents()
    QgsProject.instance().addMapLayer(v_layer)

    return

#=====================================
# Import Shapefile
#=====================================

def plot_shapefile(filename):
    """ Plotting imported shapefiles on QGIS map"""

    from qgis.utils import iface
    # testing = True
    # if testing or filename == '':
    #     filename = "C:\\Users\\blcrosbie\\dev\\GIS\\PSU_GEOG_489\\L3\\reference_data\\TM_WORLD_BORDERS-0.3.shp"
    #     print("TESTING A LOCAL FILE", filename)
    #     # layer = QgsVectorLayer(filename, 'World Borders')
    #     # QgsProject.instance().addMapLayer(layer)
    #     # for feature in layer.getFeatures():
    #     #     print(feature)
    #     #     print(feature.id())
    #     #     print(feature['NAME'])
    #     #     print('-----')


    try:
        layer = QgsVectorLayer(filename, "user_import_shape")
        QgsProject.instance().addMapLayer(layer)
        iface.mapCanvas().refreshAllLayers()
    except Exception as e:
        print(e)
        print("Failed to Plot Imported Shape")

    return






def processGetInfo(metadata):
    """ This Should Handle getInfo EE call"""
    print("COMING SOON")
    # md_type = metadata['type']
    # print(md_type)

    return

    
